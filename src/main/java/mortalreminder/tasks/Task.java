package mortalreminder.tasks;

import mortalreminder.io.FormattedPrinting;

// solution is adapted from the Course Level 3 extension
// class and constructor Javadocs were autocompleted using ChatGPT

/**
 * Represents a general task with a description, completion status, and type.
 * <p>
 * The {@code Task} class is an abstract base class for specific types of tasks such as
 * {@code Deadline}, {@code Events}, and {@code ToDo}. It provides common properties
 * and methods for handling tasks.
 */
public abstract class Task {
    protected String description;
    protected boolean isDone;
    protected String type;

    /**
     * Constructs a new {@code Task} with the specified description.
     * <p>
     * By default, the task is marked as not done.
     *
     * @param description the description of the task.
     */
    public Task(String description) {
        this.isDone = false;
    }

    public String getStatusIcon() {
        return (isDone ? "X" : " "); // mark done task with X
    }

    public String getType() {
        return type;
    }

    /**
     * Method to get the description factor of the task.
     * The description is not always the same as the description value passed into the this.description variable
     * especially for the deadline and event classes. This method assumes that the variables have been properly
     * initialised in the constructor.
     *
     * @return string of the description after processing.
     */
    public abstract String getDescription();

    /**
     * Converts the class into a string to be added to the storage file.
     * Converts all the variables from their respective object types to a string format which can be stored
     * inside the storage file and later be recognised by the parser to convert back into a task type.
     *
     * @return string of object summary to be placed into the storage text file.
     */
    public abstract String convertToFileFormat();

    // note that the rest of the methods' JavaDoc was autogenerated by ChatGPT.

    /**
     * Marks this task as done if it has not been marked already.
     * <p>
     * If the task is successfully marked as done, it calls the {@code printMarked} method
     * from {@code FormattedPrinting} to print a confirmation message.
     * <p>
     * If the task is already marked as done, it calls the {@code markError} method
     * from {@code FormattedPrinting} to print an error message.
     */
    public String markDone() {
        if (!this.isDone) {
            this.isDone = true;
            return FormattedPrinting.printMarked(this);
        } else {
            return FormattedPrinting.markError();
        }
    }

    /**
     * Marks this task as not done if it is currently marked as done.
     * <p>
     * If the task is successfully marked as undone, it calls the {@code printUnmarked} method
     * from {@code FormattedPrinting} to print a confirmation message.
     * <p>
     * If the task is already marked as not done, it calls the {@code unmarkError} method
     * from {@code FormattedPrinting} to print an error message.
     */
    public String markUndone() {
        if (this.isDone) {
            this.isDone = false;
            return FormattedPrinting.printUnmarked(this);
        } else {
            return FormattedPrinting.unmarkError();
        }
    }

    /**
     * Returns the current status of this task.
     *
     * @return {@code true} if this task is marked as done; {@code false} otherwise.
     */
    public boolean getIsDone() {
        return isDone;
    }
}
